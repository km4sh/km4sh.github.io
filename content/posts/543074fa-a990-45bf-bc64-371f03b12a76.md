---
title: "如何在Linux和macOS下配置啓動項"
date: "2021-06-18T15:14:00.121Z"
slug: "543074fa-a990-45bf-bc64-371f03b12a76"
---
# 背景介紹

我有FRP和Clash這兩個程序需要一直在後台運行，並且都與網絡相關：

1. 要在網絡啟動之後再運行
2. 網絡重啟的話也跟著重啟
3. 失敗了之後也重啟

# 部署細節

## 文件放在哪裏

### 主要的Linux系統

文件的位置在目錄`/lib/systemd/system` 下，创建一个叫做`frpc.service`另一個叫做`clash.ini`的文件就好了。

OpenWRT之類的系統通常都利用WebUI來進行交互。在WebUI當中，我們可以利用**LuCI → System → Startup**這個頁面來進行啓動服務的設置。當然，對這類可能是用來做特定事情的操作系統，像Frp之類的工具或許都有一些高級的封裝，所以也可以直接安裝相應的包，Enable之後他們也會達成相應的需求。

### MacOS系統

MacOS下面常用有兩種方式：**LaunchAgents**和**Login Items**。其中**LaunchAgents**和Linux下面的Service比較類似，而**Login Items**則是相對更加圖形化的做法。

對於**LaunchAgents**，有系統層面和当前用戶和全用户不同的放置路徑，分別是

```Shell
/Library/LaunchAgents  # for all users
~/Library/LaunchAgents  # for specific user
/System/Library/LaunchAgents  # for system
```

在這裏，我們就可以根據不同的運行要求來將一個`plist`文件放在不同的位置。

對於**Login Items**，可以在**System Preference**面板當中的**Users & Groups**頁找到。我們可以在這裏添加完成對應任務的script文件。

這裏，爲了能夠讓進程在後臺守護運行，我選擇利用`LaunchAgents`的方法來實現。

## 文件詳解

### macOS下面的`.plist`文件

這個文件描述了我設置的可以運行frpc的agent的細節。其中`ProgramArguments`鍵中記載運行frpc的指令，如果有很多參數的話，可以按照**string array**的方式來記錄。在`KeepAlive`鍵當中，我們可以將其設置爲`<true/>`來保證其持續運行。其他內容可以參考`<key> </key>`當中所描述的功能來判斷。更多功能請[參考文檔](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html)。

⚠️  __注意：請將__**`<ABSOLUTE_PATH>`** __替换对应的绝对路径。__

```XML
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC -//Apple Computer//DTD PLIST 1.0//EN
  http://www.apple.com/DTDs/PropertyList-1.0.dtd >
<plist version="1.0">
  <dict>
    <key>Label</key>
      <string>frpc</string>
    <key>ProgramArguments</key>
      <array>
        <string><ABSOLUTE_PATH>/frpc</string>
        <string>-c</string>
        <string><ABSOLUTE_PATH>/frpc.ini</string>
      </array>
    <key>KeepAlive</key>
    <true/>
    <key>RunAtLoad</key>
    <true/>
  </dict>
</plist>
```

### Linux下面的`.service`文件

Linux下面的Service描述文件則更加直觀，也方便進行更精細的控制。

例如在**Unit**下的`After`和`Wants`鍵則對應任務執行的順序和對前序任務的要求。在**Service**當中的`ExecStart`就是我們要執行的指令，`Restart`和`RestartSec`則指定了如果進程發生意外結束之後是否重啓以及經過多久之後重啓。

這裏提供了我所需要的兩項服務的Service描述。由於都是網絡相關的應用，所以前序任務都是**網絡服務啓動**並且**網絡在線**。

⚠️  __注意：請將__**`<ABSOLUTE_PATH>`** __替换对应的绝对路径。__

```Shell
[Unit]
Description=frpc service
After=network.target network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=<ABSOLUTE_PATH>/frp/frpc -c <ABSOLUTE_PATH>/frp/frpc.ini
Restart=always
RestartSec=42

[Install]
WantedBy=multi-user.target
```

```Shell
[Unit]
Description=clash proxy service
After=network.target network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=<ABSOLUTE_PATH>/clash -f <ABSOLUTE_PATH>/config.yaml
Restart=always
RestartSec=42

[Install]
WantedBy=multi-user.target
```

## 如何運行

### 對於Linux操作系統

在Linux操作系統下，可以利用`systemctl`來對服務進行控制。`systemctl enable`可以啓用服務，但默認是要在下一次滿足前序任務之後才會運行。如果想要立即運行，可以利用`systemctl start`來直接運行服務。`systemctl status`則可以看到服務的運行狀態以及服務進程的std輸出。

__在本例當中__**`$SERVICE_NAME`** __是__**`clash`** __或者__**`frpc`** __。__

```Shell
# 啟動指令
sudo systemctl enable $SERVICE_NAME
sudo systemctl start $SERVICE_NAME
sudo systemctl restart $SERVICE_NAME

# 終止指令
sudo systemctl disable $SERVICE_NAME
sudo systemctl stop $SERVICE_NAME

# 查看狀態指令
systemctl status $SERVICE_NAME
```

### 對於macOS操作系統

在macOS操作系統下，利用`launchctl`來管理**LaunchAgents**。如果在`.plist`當中配置了`RunAtLoad`的話，則可以在`launchctl load`之後直接運行。如果要查看狀態，需要在`launchctl list`當中利用`grep`查找對應服務的所在行，如果第一項`pid`是數字而非橫線符的話，則表明進程已經啓動。

__在本例當中__**`$SERVICE_NAME`** __是__**`clash.plist`** __。__

```Shell
# 啟動指令
launchctl load $SERVICE_NAME

# 終止指令
launchctl unload $SERVICE_NAME

# 查看狀態指令
launchctl list | grep $SERVICE_NAME
```

